---
title: 렌더 파이프라인 강의
date: 2023-09-04 18:00:00 +/-TTTT
categories: [Unity, Localization]
tags: [Unity, Localization]     # TAG names should always be lowercase

toc: true
toc_sticky: true
---
[![Hits](https://hits.sh/epheria.github.io.svg?view=today-total&label=visitors)](https://hits.sh/epheria.github.io/)

---

11/25 토

게임 엔진의 핵심 분석 - 김성완 교수님

g-Matrix3d neo -> 깃헙 오픈소스

https://github.com/idgmatrix?tab=repositories

1. 게임 엔진과 렌더링

다이렉트 12 - metal, vulkan. 다렉11 하고 완전히 다른 API


프레임 버퍼 - 화면을 그려주는 기능

gpu 칩 내부의 메모리 중요
- 내부 메모리를 세팅하는데 시간이 많이걸린다. 스테이트 변경 , 텍스쳐 변경 시 발생
- 내부에있는 캐시 메모리를 비우고 다시 채워야 함


레스터라이저 - 버텍스를 픽셀화 시키는 과정
삼각형 폴리곤을 픽셀화

안티 엘리어싱 - 픽셀 보정

텍스쳐를 크게 아틀라스화 하여 저장하는 이유, 텍스쳐를 자주 바꾸면 안되는 이유
-> gpu 캐시 메모리 내부에 저장할 때 지그재그로 저장. 주소 메모리가 떨어져있거나 연속적으로 처리하지 못하면 느려짐

z 버퍼링
- 픽셀 단위로 깊이값인 z 값 비교
- depth buffer
- z-fighting 현상 발생하기도 함 너무가까이 있으면

Chris Hecker - Texture Mapping
- 쌍곡선 보간
- 텍스쳐 매핑

렌더링 방식의 종류
- 포워드 렌더링
   - 가장 오래된 기본적인 방식 ㄱ
   - 가장 앞에있는 것을 그때그때 그림
   - VR 나와서 다시 사용중
   - 개별적인 물체들의 작업(버텍스, 쉐이딩 등)이 끝나면 한방에 다 그림 -> 따라서 픽셀들이 겹쳐서 그려짐 메우 낭비가 심함
   

- Deffered 렌더링
   - 지연된 렌더링이라는 뜻
   - 복잡한 조명, 그림자, 반사 등의 효과를 처리하기 위한 방법
   - 계산에 필요한 것들만 버퍼에 저장 후 마지막에 화면에 보일 부분만 계산하는 렌더링 기법
   - 마지막에 보이는 픽셀만 그리기 때문에 훨씬 빠름
   - g-buffer GEmometric Buffer
   - 단점, 투명 재질의 물체를 다를 수 없어서 별도의 처리가 필요하다.
   - 해상도가 4k 이상 높아지면 G-buffer 로 많은 메모리가 필요, 모바일에서 사용할 수없음.

- 포워드+ 렌더링
   - Light HeatMap
   - 미리 어느 부분이 라이팅 계산이 먹히는지 계산
   - 가장 최신 기술

- TBDR : Tile Based Deferred Rendering
   - 하드웨어 수준에서 발생. 모바일 디바이스 자체가 실행하기 때문에 우리가 컨트롤 할 수 없음.
   - 모바일에서 주로 사용
   - 메모리 소비를 줄이기 위해 타일 단위로 렌더링


게임 엔진별 렌더링 파이프라인 

유니티

URP 
- Forward, Deferred, Forward+ 세가지 렌더링 방식 제공

HDRP
- 고품질 실시간 렌더링을 위한 설계

언리얼 엔진 5
- 기본적으로 Deferred 렌더링
- 필요시 Forward 렌더링 옵션 켤 수 있음


VR 은 영상을 두 개 그려야함. 왼쪽 오른쪽
따라서 Deferred 강 안되고 Forward 해야함

고도 엔진
- Forward+
- 모바일 : 타일 기반
- GLES 기반렌더링 호환 가능



챕터2 렌더링 파이프라인의 구조

* 좌표계의 변환

Transform Pipeline 변환 파이프라인 OpenGL
- 가장 뼈대

좌표계의 종류
- 왼손 좌표계 DirectX , 오른손 좌표계 Open GL
- 손가락 RGB 순서
- 축의 회전방향 기준이 왼손 오른손 서로 반대임
- 오른손은 시계방향이 +, 왼손은 반시계방향이 +
- 외적의 결과는 오른손 왼손 좌표계에 따라 방향이 반대임
- Normal Vector 방향이 좌표계에 따라 방향이 뒤집어짐
- 수식으로는 구분 할 수 없다.. 외적 공식은 좌표계에 상관없이 동일

- 구면 좌표계 (우주적 관점)
- BRDF 양방향 반사 분포 함수 : 입사광 반사광 등

- 구면 조화 함수
- 양자 역학, 조명 등

- 원통 좌표계 등이 있다.


텍스쳐 좌표계 UV 원점과 방향
왼쪽 아래가 원점인 경우, 왼쪽 위가 원점인 경우도 있다.
-> 텍스쳐가 뒤집어져서 보이는 이유..

유니티는 왼쪽 아래


행렬 변환의 수학적 특성
- 2차원 변환 행렬인데 왜 3x3 으로 표현?
- 이동 변환 : 행렬의 덧셈
- 크기 , 회전 변환 : 행렬의 곱셈
- 곱셈으로 통일할 방법이 필요해짐

행렬 연산의 혼재
- 회전 변환은 곱셈, 이동변환은 덧셈
- 모든 변환이 곱셈으로 표현 가능 -> 아핀 affine 변환
- 없는 좌표를 하나 추가한 형태.

동치/동차 Homegeneous 좌표계로 확장
- 2차원 변환을 모두 3x3 행렬의 곱으로 나타낼 수 있음.
- 이동, 회전, 크기, 전단 변환 다 적용 가능

Rigid / Euclidean 변환
길이와 각도 보존
항등, 이동, 회전 변환

Rigid 강체 -  물체의 모양은 절대 변하지 않는다. 위치,회전값이 바뀐다.

회전 변환 행렬
- 직교 행렬
- 역행렬, 전치행렬, 각도값에다가 -를 해주면 모두 같다.


닮음 변환 - 스케일링
- 등방 크기 변환
- 각도가 보존 됨


선형 변환 Linear Transform
- 상수를 곱하는 것
- 행렬의 곱으로 나타낼 수 ㅅ있으


아핀 변환 Affine Transformation
- 평행선이 보존된다.
- 대수적으로 본다면 선형변환식에 상수항이 추가됨
x' = ax + by + c
y' = dx + ey + f
- 아핀 변환의 총집합은 대수적으로는 1차 다항식의 형태로 표현가능
- Orthographic


투영 변환 Projective Transformation
- 직선은 직선 그대로 보존, 하지만 평행선은 보존되지 않음
- 원근 Perspective 투영 변환
- 행렬 곱셈만으로는 표현이 불가능
- Perspective



일반적인 변환
- 직선이 보존되지 않는다
- 핀쿠션 왜곡, 배럴 왜곡
- VR 에서 사용 -> Oculus Rift : 술통 왜곡 Barrel Distortion -> 이거 사실 실물 렌즈로 구현해야하는데 그래픽스의 발전으로 렌더링 효과로 표현ㅋㅋ


어안 렌즈 변환 Fish eye Transform
- 물속 표현


360 degree 파노라마 변환
등이 있다!


변환 순서의 중요성

같은 90 도, 같은 x 방향이동이지만 결과값이 달라진다.
1. 90 도 회전 -> x 방향 이동
2. x 방향 이동 -> 90 도 회전



변환의 합성과 행렬의 곱
- 행렬의 곱은 교환 법칙이 성립하지 않음
- 변환의 합성 순서에 따라 결과값이 달라짐


변환 순서와 행렬곱의 순서

- D3D 에선 변환의 순서와 행렬 곱의 순서가 서로 동일  위치 벡터 : 행 벡터
- OGL 에선 변환의 순서와 행렬 곱의 순서가 역순이다.  위치 벡터 : 열 벡터

행우선인지 열우선인지에 따라 다르기 때문


월드 변환의 순서
- 표준임
- SRT : Scale 변환 -> Rotation 변환 -> Translate 변환



유니티의 오일러 앵글 회전 변환 순서 : Z, X, Y

X 축 회전 Pitch
Y 축 회전 Yaw
Z 축 회전 Roll

카메라의 짐벌락을 피하기 좋은 순서





모델 공간 -> 월드 공간

회전을 표현할 때
2차원에서는 복소수로 표현가능
3차원에서는 표현할게 없어서 쿼터니언으로 표현



카메라 변환 행렬
- 뷰 변환
- 카메라 변환은 월드 공간에서 카메라를 강체변환 한 것의 역 변환임.
- (R * T)인버스 = T 인버스 * R 인버스



Normal 벡터의 변환 특성
- 좌표점과 다른 변환이 필요
- 등방 스케일링이면 상관없는데 한 쪽 축만 스케일링이 되면 노멀 벡터값이 달라질 수 있음
- 즉 크기가 비등방적으로 커지더라도 각각에서 제대로 수직 방향을 표시할 수 있어야함
- 두 벡터를 내적하면 0 -> 수직임



원근 투영 변환 행렬
- 파이프라인 변환에서 가장 어려운 부분
- z 값이 다 고정된 값으로 변환 되어 버림, 깊이 정보가 사라짐
- z값이 z-buffering 이 가능하도록 범위를 가져야 함
- FOV 나 시야 범위를 손쉽게 조절 가능해야함

-> z 버퍼링, 원근 투영 변환 적용하여 바뀐게 

NDC normalized device coordinates

뷰 절두체 Frustum -> NDC 로 바꿔야함


챕터3 레이트레이싱 실습

GLSL

빛의 성질 - 빛의 이중성 입자와 파동

스넬의 법칙 : 굴절계수에 따라 굴절각을 구할 수 있다.

굴절 계수 : 진공 1.0, 공기 1.003, 물1.33...


파동의 굴절 : 호이겐스의 원리

빛의 에너지 : 반사, 흡수, 굴절 (애너지 보존)

요즘 물리기반엔진에서는 빛의 에너지성도 고려한다..ㄷㄷ
빛이 입사할 때 일부는 반사, 일부는 흡수하는 등

반사색의 원리 : 물체의 재질, 고유색

반사하는 성질 : 프레넬 효과
- 예리한 각도에서 강하게 반사
- 입사각에 따라 반사되는 형태가 다르다
- 프레넬 방정식 : 빛의 편광 현상
- 입사각에 따른 횡파와 종파의 반사율
- 에너지 보존 법칙도 프레넬 방정식으로 구해야하고..
- 부도체와 금속의 프레넬 반사율이 또 다르고..
- 빛이 굴절할 때 파장에 따라 굴절률이 또 달라진다.. -> 무지개
- 파동의 간섭 : 보강과 상쇄도 있음ㅎㅎ
- 예. 비누막 간섭(보강), 안경 렌즈의 무반사 코팅(상쇄) -> 옛날에는 렌즈에 반사되서 안경낀 사람의 눈이 안보였다고..
- 파동의 회절
- 빛의 산란 Scattering -> 구름    레일리 산란, 미 산란
- 파란하늘 -> 공기 중의 레일리 산란 효과


- Physics and Math of Shading 에서 자세히 알아볼수있음ㅎㅎ



Phong Reflection Model Formula = Specular + Diffuse + Ambient
- 에너지 보존 법칙은 무시한다. 모든 값을 다 더해서 표현
- 과거의 컴퓨터 그래픽스의 모습. 플라스틱 느낌

Specular  정반사, 거울반사, 매끈한 표면
Diffuse  전반사, 난반사, 확산광, 미세하게 거친 표면

- 페이스 노말, 버텍스 노말, 픽셀 노말(최신)
- 퐁 셰이딩 : 버텍스 노말 벡터의 보간이 필요. 보간된 노말 벡터로 픽셀 마다 조명 계산을 실시


- 노말 맵
- 단점 : 페이크 기법이기 때문에 지오메트리를 바꿀 수 없다. 유심히 보면 뽀록남



- 요즘은 PBR 같은 사실적인 반사 모델을 사용한다.
- 특히 인체 피부 질감 표현
- 금속의 경우 BRDF 양방향 반사 분포 함수를 통해 사실적인 재질 표면을 보여줄 수 있따.


PBR  Physically Based Rendering


GI  Global Illumination
- 간접 조명을 다룬다.
- 고전적 방법 -> 베이크해서 구워놓음
- 요즘은 언리얼 5에서 루멘같이 실시간으로 GI 기능을 제공한다.
- Ray Tracing : qkstk, rnfwjf
- Radiosity : diffuse 반사만 


ShaderToy  WebGL 기반

https://www.shadertoy.com/user/kaswan/sort=popular&from=0&num=8

WebGL < OpenGL ES < OpenGL

올해 WebGL 의 차기 버전이 나옴 -> WebGPU - Rust 언어 사용ㅋㅋ
- 인공지능에서 주로 사용
- WebGL 은 C# 기반 GLSL 사용 -> 유니티 HLSL 과 비슷



프랙탈 표현
- 만델브로트 집합을 만드는 공식을 사용
- 복소수 공간에서 표현



레이트레이싱

- 입사각과 반사각이 같은 공식을 사용하여
- 카메라에서 빛을 쏴서 광원에서 반사된 빛이 들어온것 = 카메라에서 빛을 쏜 것 과 같기 때문에
- 간단하고 작은 레이를 가지고 구현이 가능하다.
- 그림자 그리기도 쉽다.
- 하드웨어에서 레이트레이싱이 가능해지고나서 
- 기존에는 폴리곤 렌더링으로 그리고 그림자,반사되는 부분만 레이트레이싱을 사용
- 레이트레이싱에서 구가 제일 표현하기 쉽다? 폴리곤 렌더링은 힘든데
- 구와 관련된 수학공식 - 교점을 구하는 공식이 근의 공식을 사용하여 레이가 구와 접촉을 하는지 간편하게 구할 수 있기 때문
- 결론은 수학을 잘하자
