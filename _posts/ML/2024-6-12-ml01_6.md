---
title: Machine Learning - Multiple Linear Regression
date: 2024-5-7 22:00:00 +/-TTTT
categories: [ML, Supervised Machine Learning]
tags: [Machine Learning, ML, Multiple Linear Regression]     # TAG names should always be lowercase

toc: true
toc_sticky: true
math: true  
use_math: true
mermaid: true

---

[![Hits](https://hits.sh/epheria.github.io.svg?view=today-total&label=visitors)](https://hits.sh/epheria.github.io/)

---

<br>

> 해당 포스트는 Andrew Ng 교수님의  [**Machine Learning Specialization**](https://www.coursera.org/specializations/machine-learning-introduction) 특화 과정에 대한 정리 내용을 참고하였습니다.

<br>
<br>

## 목차
---


<br>
<br>




<br>

## 실습

#### Problem Statement**
- 주택 가격 예측을 위한 예제를 그대로 사용한다. 훈련 데이터셋에는 네가지 특징 (크기, 침실 수, 층 수, 햇수)을 포함한 세 가지 예제가 아래 표에 나와있다.

####  Dataset: 

| Size (sqft) | Number of Bedrooms  | Number of floors | Age of  Home | Price (1000s dollars)  |   
| ----------------| ------------------- |----------------- |--------------|----------------------- |  
| 952             | 2                   | 1                | 65           | 271.5                  |  
| 1244            | 3                   | 2                | 64           | 232                    |  
| 1947            | 3                   | 2                | 17           | 509.8                  |  
| ...             | ...                 | ...              | ...          | ...                    |

<br>

```python
# load the dataset
X_train, y_train = load_house_data()
X_features = ['size(sqft)','bedrooms','floors','age']
```

- 데이터셋과 그 특징들을 보기 위해 각 특징을 가격과 함께 그래프로 나타내보자.

```python
fig, ax = plt.subplots(1, 4, figzie=(12,3), sharey=True)
for i in range(len(ax)):
    ax[i].scatter(X_train[:, i], y_train)
    ax[i].set_xlabel(X_features[i])
ax[0].set_ylabel("Price (1000's)")
plt.show()
```

![Desktop View](/assets/img/post/ml/ml05_07.png){: : width="800" .normal }    

- 각 특징을 목표값인 가격과 비교하여 플로팅하는 것은 어떤 특징이 가격에 가장 큰 영향을 미치는지에 대한 일부 힌트를 제공한다.
- 위 그림에서 본 것처럼, 크기가 증가하면 가격도 증가한다. 침실 수와 층 수는 가격에 큰 영향을 미치지 않는 것으로 보인다. 또한 새로운 집일 수록 가격이 높다.

<br>

#### Gradient Descent With Multiple Variables

- gradient descent for multiple variables 방정식은 다음과 같다.

$$\begin{align*} \text{repeat}&\text{ until convergence:} \; \lbrace \newline\;
& w_j := w_j -  \alpha \frac{\partial J(\mathbf{w},b)}{\partial w_j} \tag{1}  \; & \text{for j = 0..n-1}\newline
&b\ \ := b -  \alpha \frac{\partial J(\mathbf{w},b)}{\partial b}  \newline \rbrace
\end{align*}$$

- 여기서 $n$ 은 특징의 개수이며, 매개변수 $w_j$ 와 $b$ 는 동시에 업데이트된다.

$$
\begin{align}
\frac{\partial J(\mathbf{w},b)}{\partial w_j}  &= \frac{1}{m} \sum\limits_{i = 0}^{m-1} (f_{\mathbf{w},b}(\mathbf{x}^{(i)}) - y^{(i)})x_{j}^{(i)} \tag{2}  \\
\frac{\partial J(\mathbf{w},b)}{\partial b}  &= \frac{1}{m} \sum\limits_{i = 0}^{m-1} (f_{\mathbf{w},b}(\mathbf{x}^{(i)}) - y^{(i)}) \tag{3}
\end{align}
$$

- $m$ 은 데이터셋의 훈련 예제 개수이며
-  $f_{\mathbf{w},b}(\mathbf{x}^{(i)})$ 는 모델의 예측값이고, $y^{(i)}$ 는 목표값이다.

<br>

#### Learning Rate

- 학습률 $\alpha$ 는 매개변수 업데이트의 크기를 제어한다. 경사 하강법을 실행하고 데이터셋에 대해 몇 가지 $\alpha$ 설정을 시도해 보자.

<br>

### $\alpha$ = 9.9e-7

```python
# set alpha to 9.9e-7
_, _, hist = run_gradient_descent(X_train, y_train, 10, alpha = 9.9e-7)
```

```console
Iteration Cost          w0       w1       w2       w3       b       djdw0    djdw1    djdw2    djdw3    djdb  
---------------------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|
        0 9.55884e+04  5.5e-01  1.0e-03  5.1e-04  1.2e-02  3.6e-04 -5.5e+05 -1.0e+03 -5.2e+02 -1.2e+04 -3.6e+02
        1 1.28213e+05 -8.8e-02 -1.7e-04 -1.0e-04 -3.4e-03 -4.8e-05  6.4e+05  1.2e+03  6.2e+02  1.6e+04  4.1e+02
        2 1.72159e+05  6.5e-01  1.2e-03  5.9e-04  1.3e-02  4.3e-04 -7.4e+05 -1.4e+03 -7.0e+02 -1.7e+04 -4.9e+02
        3 2.31358e+05 -2.1e-01 -4.0e-04 -2.3e-04 -7.5e-03 -1.2e-04  8.6e+05  1.6e+03  8.3e+02  2.1e+04  5.6e+02
        4 3.11100e+05  7.9e-01  1.4e-03  7.1e-04  1.5e-02  5.3e-04 -1.0e+06 -1.8e+03 -9.5e+02 -2.3e+04 -6.6e+02
        5 4.18517e+05 -3.7e-01 -7.1e-04 -4.0e-04 -1.3e-02 -2.1e-04  1.2e+06  2.1e+03  1.1e+03  2.8e+04  7.5e+02
        6 5.63212e+05  9.7e-01  1.7e-03  8.7e-04  1.8e-02  6.6e-04 -1.3e+06 -2.5e+03 -1.3e+03 -3.1e+04 -8.8e+02
        7 7.58122e+05 -5.8e-01 -1.1e-03 -6.2e-04 -1.9e-02 -3.4e-04  1.6e+06  2.9e+03  1.5e+03  3.8e+04  1.0e+03
        8 1.02068e+06  1.2e+00  2.2e-03  1.1e-03  2.3e-02  8.3e-04 -1.8e+06 -3.3e+03 -1.7e+03 -4.2e+04 -1.2e+03
        9 1.37435e+06 -8.7e-01 -1.7e-03 -9.1e-04 -2.7e-02 -5.2e-04  2.1e+06  3.9e+03  2.0e+03  5.1e+04  1.4e+03
w,b found by gradient descent: w: [-0.87 -0.   -0.   -0.03], b: -0.00
```

- 총 10회 반복을 진행하였고, 가중치 $w$ 와 절편 $b$ 를 살펴보면, 반복될 때 마다 크게 변동되고 있는 것을 확인할 수 있다.
- 이는 학습률이 너무 높아 최적의 값을 Overshooting(초과) 하고 있다는 것을 의미한다.
- 즉, 가중치의 변동이 크고, 매 반복마다 음수에서 양수로 번갈아가면서 변하고 있다.
- gradient 값인 djdw0, ... , djdb 도 마찬가지이다. 매 반복마다 큰 값으로 나타나고 있고 이는 비용함수의 기울기가 급격하다는 것을 의미한다.
- 따라서, 학습률이 너무 높다. 비용이 감소하지 않고 오히려 증가하고있다. 그래프로 나타내면 다음과 같다.

<br>

```python
plot_cost_i_w(X_train, y_train, hist)
```

![Desktop View](/assets/img/post/ml/ml05_08.png){: : width="800" .normal }    

- 오른쪽 그래프는 매개변수 중 하나인 $w_0$ 값을 보여주고 있다. 각 반복에서 최적값을 초과하고 있으며, 그 결과 비용이 최소값에 접근하지 않고 증가하고 있다.

<br>

### $\alpha$ = 9e-7

- 좀 더 작은 학습률로 다시 테스트 해보면

```python
#set alpha to 9e-7
_,_,hist = run_gradient_descent(X_train, y_train, 10, alpha = 9e-7)
```

```console
Iteration Cost          w0       w1       w2       w3       b       djdw0    djdw1    djdw2    djdw3    djdb  
---------------------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|
        0 6.64616e+04  5.0e-01  9.1e-04  4.7e-04  1.1e-02  3.3e-04 -5.5e+05 -1.0e+03 -5.2e+02 -1.2e+04 -3.6e+02
        1 6.18990e+04  1.8e-02  2.1e-05  2.0e-06 -7.9e-04  1.9e-05  5.3e+05  9.8e+02  5.2e+02  1.3e+04  3.4e+02
        2 5.76572e+04  4.8e-01  8.6e-04  4.4e-04  9.5e-03  3.2e-04 -5.1e+05 -9.3e+02 -4.8e+02 -1.1e+04 -3.4e+02
        3 5.37137e+04  3.4e-02  3.9e-05  2.8e-06 -1.6e-03  3.8e-05  4.9e+05  9.1e+02  4.8e+02  1.2e+04  3.2e+02
        4 5.00474e+04  4.6e-01  8.2e-04  4.1e-04  8.0e-03  3.2e-04 -4.8e+05 -8.7e+02 -4.5e+02 -1.1e+04 -3.1e+02
        5 4.66388e+04  5.0e-02  5.6e-05  2.5e-06 -2.4e-03  5.6e-05  4.6e+05  8.5e+02  4.5e+02  1.2e+04  2.9e+02
        6 4.34700e+04  4.5e-01  7.8e-04  3.8e-04  6.4e-03  3.2e-04 -4.4e+05 -8.1e+02 -4.2e+02 -9.8e+03 -2.9e+02
        7 4.05239e+04  6.4e-02  7.0e-05  1.2e-06 -3.3e-03  7.3e-05  4.3e+05  7.9e+02  4.2e+02  1.1e+04  2.7e+02
        8 3.77849e+04  4.4e-01  7.5e-04  3.5e-04  4.9e-03  3.2e-04 -4.1e+05 -7.5e+02 -3.9e+02 -9.1e+03 -2.7e+02
        9 3.52385e+04  7.7e-02  8.3e-05 -1.1e-06 -4.2e-03  8.9e-05  4.0e+05  7.4e+02  3.9e+02  1.0e+04  2.5e+02
w,b found by gradient descent: w: [ 7.74e-02  8.27e-05 -1.06e-06 -4.20e-03], b: 0.00
```

- 가중치의 값은 초기 값에서 조금씩 변화하여 최적의 값을 향해 수렴하고있다. 절편값은 거의 변하지 않는다.
- 그래디언트 값은 반복이 진행됨에 따라 점차 감소하고 있다. 이는 모델이 점점 최적화되고 있으며, 경사 하강법 알골지ㅡㅁ이 수렴하고 있음을 나타낸다.

<br>

```python
plot_cost_i_w(X_train, y_train, hist)
```

![Desktop View](/assets/img/post/ml/ml05_09.png){: : width="800" .normal }    

- 왼쪽 그래프를 보면 비용이 예상대로 감소하고 있음을 확인할 수 있다. 오른쪽 그래프는 $w_0$ 가 여전히 최소값 주위에서 진동하고 있지만, 비용이 반복할 때 마다 증가하지 않고 감소하고 있다.
- 그래디언트값 dj_dw[0] 가 각 반복마다 부호가 바뀌는 것을 확인할 수 있다. 이는 $w_0$ 가 최적값을 넘어서 점프하기 때문이다. 이 학습률은 수렴한다.

<br>

### $\alpha$ = 1e-7

- 학습률을 좀 더 줄여보자.

```python
#set alpha to 1e-7
_,_,hist = run_gradient_descent(X_train, y_train, 10, alpha = 1e-7)
```

```console
Iteration Cost          w0       w1       w2       w3       b       djdw0    djdw1    djdw2    djdw3    djdb  
---------------------|--------|--------|--------|--------|--------|--------|--------|--------|--------|--------|
        0 4.42313e+04  5.5e-02  1.0e-04  5.2e-05  1.2e-03  3.6e-05 -5.5e+05 -1.0e+03 -5.2e+02 -1.2e+04 -3.6e+02
        1 2.76461e+04  9.8e-02  1.8e-04  9.2e-05  2.2e-03  6.5e-05 -4.3e+05 -7.9e+02 -4.0e+02 -9.5e+03 -2.8e+02
        2 1.75102e+04  1.3e-01  2.4e-04  1.2e-04  2.9e-03  8.7e-05 -3.4e+05 -6.1e+02 -3.1e+02 -7.3e+03 -2.2e+02
        3 1.13157e+04  1.6e-01  2.9e-04  1.5e-04  3.5e-03  1.0e-04 -2.6e+05 -4.8e+02 -2.4e+02 -5.6e+03 -1.8e+02
        4 7.53002e+03  1.8e-01  3.3e-04  1.7e-04  3.9e-03  1.2e-04 -2.1e+05 -3.7e+02 -1.9e+02 -4.2e+03 -1.4e+02
        5 5.21639e+03  2.0e-01  3.5e-04  1.8e-04  4.2e-03  1.3e-04 -1.6e+05 -2.9e+02 -1.5e+02 -3.1e+03 -1.1e+02
        6 3.80242e+03  2.1e-01  3.8e-04  1.9e-04  4.5e-03  1.4e-04 -1.3e+05 -2.2e+02 -1.1e+02 -2.3e+03 -8.6e+01
        7 2.93826e+03  2.2e-01  3.9e-04  2.0e-04  4.6e-03  1.4e-04 -9.8e+04 -1.7e+02 -8.6e+01 -1.7e+03 -6.8e+01
        8 2.41013e+03  2.3e-01  4.1e-04  2.1e-04  4.7e-03  1.5e-04 -7.7e+04 -1.3e+02 -6.5e+01 -1.2e+03 -5.4e+01
        9 2.08734e+03  2.3e-01  4.2e-04  2.1e-04  4.8e-03  1.5e-04 -6.0e+04 -1.0e+02 -4.9e+01 -7.5e+02 -4.3e+01
w,b found by gradient descent: w: [2.31e-01 4.18e-04 2.12e-04 4.81e-03], b: 0.00
```

- 비용이 매 반복마다 꾸준히 감소하여 알고리즘이 비용 함수를 효과적으로 최소화하고 있음을 보여준다.
- 반복이 진행됨에 따라 기울기(djdw)의 크기가 감소한다. 기울기가 감소한다는 것은 알고리즘이 비용 함수를 최소화하는 최적의 지점에 접근하고 있음을 의미한다.

<br>

![Desktop View](/assets/img/post/ml/ml05_10.png){: : width="800" .normal }    

- 왼쪽 그래프를 보면, 비용이 감소하고 있고 오른쪽 그래프를 보면 $w_0$ 가 진동없이 최소값에 잘 수렴하는 것을 확인할 수 있다.
- dj_w0 값도 모든 반복에서 음수를 나타낸다.